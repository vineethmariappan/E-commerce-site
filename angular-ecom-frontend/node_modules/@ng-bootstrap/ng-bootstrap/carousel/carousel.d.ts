import { AfterContentChecked, AfterContentInit, ChangeDetectorRef, EventEmitter, NgZone, OnChanges, OnDestroy, QueryList, TemplateRef } from '@angular/core';
import { NgbCarouselConfig } from './carousel-config';
/**
 * A directive that wraps the individual carousel slide.
 */
import * as ɵngcc0 from '@angular/core';
export declare class NgbSlide {
    tplRef: TemplateRef<any>;
    /**
     * Slide id that must be unique for the entire document.
     *
     * If not provided, will be generated in the `ngb-slide-xx` format.
     */
    id: string;
    constructor(tplRef: TemplateRef<any>);
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NgbSlide>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<NgbSlide, "ng-template[ngbSlide]", never, {
    "id": "id";
}, {}, never>;
}
/**
 * Carousel is a component to easily create and control slideshows.
 *
 * Allows to set intervals, change the way user interacts with the slides and provides a programmatic API.
 */
export declare class NgbCarousel implements AfterContentChecked, AfterContentInit, OnChanges, OnDestroy {
    private _platformId;
    private _ngZone;
    private _cd;
    slides: QueryList<NgbSlide>;
    private _destroy$;
    private _start$;
    private _stop$;
    /**
     * The slide id that should be displayed **initially**.
     *
     * For subsequent interactions use methods `select()`, `next()`, etc. and the `(slide)` output.
     */
    activeId: string;
    /**
     * Time in milliseconds before the next slide is shown.
     */
    interval: number;
    /**
     * If `true`, will 'wrap' the carousel by switching from the last slide back to the first.
     */
    wrap: boolean;
    /**
     * If `true`, allows to interact with carousel using keyboard 'arrow left' and 'arrow right'.
     */
    keyboard: boolean;
    /**
     * If `true`, will pause slide switching when mouse cursor hovers the slide.
     *
     * @since 2.2.0
     */
    pauseOnHover: boolean;
    /**
     * If `true`, 'previous' and 'next' navigation arrows will be visible on the slide.
     *
     * @since 2.2.0
     */
    showNavigationArrows: boolean;
    /**
     * If `true`, navigation indicators at the bottom of the slide will be visible.
     *
     * @since 2.2.0
     */
    showNavigationIndicators: boolean;
    /**
     * An event emitted right after the slide transition is completed.
     *
     * See [`NgbSlideEvent`](#/components/carousel/api#NgbSlideEvent) for payload details.
     */
    slide: EventEmitter<NgbSlideEvent>;
    constructor(config: NgbCarouselConfig, _platformId: any, _ngZone: NgZone, _cd: ChangeDetectorRef);
    ngAfterContentInit(): void;
    ngAfterContentChecked(): void;
    ngOnDestroy(): void;
    ngOnChanges(changes: any): void;
    /**
     * Navigates to a slide with the specified identifier.
     */
    select(slideId: string): void;
    /**
     * Navigates to the previous slide.
     */
    prev(): void;
    /**
     * Navigates to the next slide.
     */
    next(): void;
    /**
     * Pauses cycling through the slides.
     */
    pause(): void;
    /**
     * Restarts cycling through the slides from left to right.
     */
    cycle(): void;
    private _cycleToSelected;
    private _getSlideEventDirection;
    private _getSlideById;
    private _getSlideIdxById;
    private _getNextSlide;
    private _getPrevSlide;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NgbCarousel>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<NgbCarousel, "ngb-carousel", ["ngbCarousel"], {
    "interval": "interval";
    "wrap": "wrap";
    "keyboard": "keyboard";
    "pauseOnHover": "pauseOnHover";
    "showNavigationArrows": "showNavigationArrows";
    "showNavigationIndicators": "showNavigationIndicators";
    "activeId": "activeId";
}, {
    "slide": "slide";
}, ["slides"]>;
}
/**
 * A slide change event emitted right after the slide transition is completed.
 */
export interface NgbSlideEvent {
    /**
     * The previous slide id.
     */
    prev: string;
    /**
     * The current slide id.
     */
    current: string;
    /**
     * The slide event direction.
     *
     * Possible values are `'left' | 'right'`.
     */
    direction: NgbSlideEventDirection;
}
/**
 * Defines the carousel slide transition direction.
 */
export declare enum NgbSlideEventDirection {
    LEFT,
    RIGHT
}
export declare const NGB_CAROUSEL_DIRECTIVES: (typeof NgbSlide | typeof NgbCarousel)[];

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2Fyb3VzZWwuZC50cyIsInNvdXJjZXMiOlsiY2Fyb3VzZWwuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0FBS0E7Ozs7Ozs7Ozs7Ozs7QUFTQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUZBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWZ0ZXJDb250ZW50Q2hlY2tlZCwgQWZ0ZXJDb250ZW50SW5pdCwgQ2hhbmdlRGV0ZWN0b3JSZWYsIEV2ZW50RW1pdHRlciwgTmdab25lLCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgUXVlcnlMaXN0LCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTmdiQ2Fyb3VzZWxDb25maWcgfSBmcm9tICcuL2Nhcm91c2VsLWNvbmZpZyc7XG4vKipcbiAqIEEgZGlyZWN0aXZlIHRoYXQgd3JhcHMgdGhlIGluZGl2aWR1YWwgY2Fyb3VzZWwgc2xpZGUuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE5nYlNsaWRlIHtcbiAgICB0cGxSZWY6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgLyoqXG4gICAgICogU2xpZGUgaWQgdGhhdCBtdXN0IGJlIHVuaXF1ZSBmb3IgdGhlIGVudGlyZSBkb2N1bWVudC5cbiAgICAgKlxuICAgICAqIElmIG5vdCBwcm92aWRlZCwgd2lsbCBiZSBnZW5lcmF0ZWQgaW4gdGhlIGBuZ2Itc2xpZGUteHhgIGZvcm1hdC5cbiAgICAgKi9cbiAgICBpZDogc3RyaW5nO1xuICAgIGNvbnN0cnVjdG9yKHRwbFJlZjogVGVtcGxhdGVSZWY8YW55Pik7XG59XG4vKipcbiAqIENhcm91c2VsIGlzIGEgY29tcG9uZW50IHRvIGVhc2lseSBjcmVhdGUgYW5kIGNvbnRyb2wgc2xpZGVzaG93cy5cbiAqXG4gKiBBbGxvd3MgdG8gc2V0IGludGVydmFscywgY2hhbmdlIHRoZSB3YXkgdXNlciBpbnRlcmFjdHMgd2l0aCB0aGUgc2xpZGVzIGFuZCBwcm92aWRlcyBhIHByb2dyYW1tYXRpYyBBUEkuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE5nYkNhcm91c2VsIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50Q2hlY2tlZCwgQWZ0ZXJDb250ZW50SW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xuICAgIHByaXZhdGUgX3BsYXRmb3JtSWQ7XG4gICAgcHJpdmF0ZSBfbmdab25lO1xuICAgIHByaXZhdGUgX2NkO1xuICAgIHNsaWRlczogUXVlcnlMaXN0PE5nYlNsaWRlPjtcbiAgICBwcml2YXRlIF9kZXN0cm95JDtcbiAgICBwcml2YXRlIF9zdGFydCQ7XG4gICAgcHJpdmF0ZSBfc3RvcCQ7XG4gICAgLyoqXG4gICAgICogVGhlIHNsaWRlIGlkIHRoYXQgc2hvdWxkIGJlIGRpc3BsYXllZCAqKmluaXRpYWxseSoqLlxuICAgICAqXG4gICAgICogRm9yIHN1YnNlcXVlbnQgaW50ZXJhY3Rpb25zIHVzZSBtZXRob2RzIGBzZWxlY3QoKWAsIGBuZXh0KClgLCBldGMuIGFuZCB0aGUgYChzbGlkZSlgIG91dHB1dC5cbiAgICAgKi9cbiAgICBhY3RpdmVJZDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRpbWUgaW4gbWlsbGlzZWNvbmRzIGJlZm9yZSB0aGUgbmV4dCBzbGlkZSBpcyBzaG93bi5cbiAgICAgKi9cbiAgICBpbnRlcnZhbDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIElmIGB0cnVlYCwgd2lsbCAnd3JhcCcgdGhlIGNhcm91c2VsIGJ5IHN3aXRjaGluZyBmcm9tIHRoZSBsYXN0IHNsaWRlIGJhY2sgdG8gdGhlIGZpcnN0LlxuICAgICAqL1xuICAgIHdyYXA6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogSWYgYHRydWVgLCBhbGxvd3MgdG8gaW50ZXJhY3Qgd2l0aCBjYXJvdXNlbCB1c2luZyBrZXlib2FyZCAnYXJyb3cgbGVmdCcgYW5kICdhcnJvdyByaWdodCcuXG4gICAgICovXG4gICAga2V5Ym9hcmQ6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogSWYgYHRydWVgLCB3aWxsIHBhdXNlIHNsaWRlIHN3aXRjaGluZyB3aGVuIG1vdXNlIGN1cnNvciBob3ZlcnMgdGhlIHNsaWRlLlxuICAgICAqXG4gICAgICogQHNpbmNlIDIuMi4wXG4gICAgICovXG4gICAgcGF1c2VPbkhvdmVyOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIElmIGB0cnVlYCwgJ3ByZXZpb3VzJyBhbmQgJ25leHQnIG5hdmlnYXRpb24gYXJyb3dzIHdpbGwgYmUgdmlzaWJsZSBvbiB0aGUgc2xpZGUuXG4gICAgICpcbiAgICAgKiBAc2luY2UgMi4yLjBcbiAgICAgKi9cbiAgICBzaG93TmF2aWdhdGlvbkFycm93czogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBJZiBgdHJ1ZWAsIG5hdmlnYXRpb24gaW5kaWNhdG9ycyBhdCB0aGUgYm90dG9tIG9mIHRoZSBzbGlkZSB3aWxsIGJlIHZpc2libGUuXG4gICAgICpcbiAgICAgKiBAc2luY2UgMi4yLjBcbiAgICAgKi9cbiAgICBzaG93TmF2aWdhdGlvbkluZGljYXRvcnM6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQW4gZXZlbnQgZW1pdHRlZCByaWdodCBhZnRlciB0aGUgc2xpZGUgdHJhbnNpdGlvbiBpcyBjb21wbGV0ZWQuXG4gICAgICpcbiAgICAgKiBTZWUgW2BOZ2JTbGlkZUV2ZW50YF0oIy9jb21wb25lbnRzL2Nhcm91c2VsL2FwaSNOZ2JTbGlkZUV2ZW50KSBmb3IgcGF5bG9hZCBkZXRhaWxzLlxuICAgICAqL1xuICAgIHNsaWRlOiBFdmVudEVtaXR0ZXI8TmdiU2xpZGVFdmVudD47XG4gICAgY29uc3RydWN0b3IoY29uZmlnOiBOZ2JDYXJvdXNlbENvbmZpZywgX3BsYXRmb3JtSWQ6IGFueSwgX25nWm9uZTogTmdab25lLCBfY2Q6IENoYW5nZURldGVjdG9yUmVmKTtcbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZDtcbiAgICBuZ0FmdGVyQ29udGVudENoZWNrZWQoKTogdm9pZDtcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogTmF2aWdhdGVzIHRvIGEgc2xpZGUgd2l0aCB0aGUgc3BlY2lmaWVkIGlkZW50aWZpZXIuXG4gICAgICovXG4gICAgc2VsZWN0KHNsaWRlSWQ6IHN0cmluZyk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogTmF2aWdhdGVzIHRvIHRoZSBwcmV2aW91cyBzbGlkZS5cbiAgICAgKi9cbiAgICBwcmV2KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogTmF2aWdhdGVzIHRvIHRoZSBuZXh0IHNsaWRlLlxuICAgICAqL1xuICAgIG5leHQoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBQYXVzZXMgY3ljbGluZyB0aHJvdWdoIHRoZSBzbGlkZXMuXG4gICAgICovXG4gICAgcGF1c2UoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBSZXN0YXJ0cyBjeWNsaW5nIHRocm91Z2ggdGhlIHNsaWRlcyBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICovXG4gICAgY3ljbGUoKTogdm9pZDtcbiAgICBwcml2YXRlIF9jeWNsZVRvU2VsZWN0ZWQ7XG4gICAgcHJpdmF0ZSBfZ2V0U2xpZGVFdmVudERpcmVjdGlvbjtcbiAgICBwcml2YXRlIF9nZXRTbGlkZUJ5SWQ7XG4gICAgcHJpdmF0ZSBfZ2V0U2xpZGVJZHhCeUlkO1xuICAgIHByaXZhdGUgX2dldE5leHRTbGlkZTtcbiAgICBwcml2YXRlIF9nZXRQcmV2U2xpZGU7XG59XG4vKipcbiAqIEEgc2xpZGUgY2hhbmdlIGV2ZW50IGVtaXR0ZWQgcmlnaHQgYWZ0ZXIgdGhlIHNsaWRlIHRyYW5zaXRpb24gaXMgY29tcGxldGVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5nYlNsaWRlRXZlbnQge1xuICAgIC8qKlxuICAgICAqIFRoZSBwcmV2aW91cyBzbGlkZSBpZC5cbiAgICAgKi9cbiAgICBwcmV2OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgc2xpZGUgaWQuXG4gICAgICovXG4gICAgY3VycmVudDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBzbGlkZSBldmVudCBkaXJlY3Rpb24uXG4gICAgICpcbiAgICAgKiBQb3NzaWJsZSB2YWx1ZXMgYXJlIGAnbGVmdCcgfCAncmlnaHQnYC5cbiAgICAgKi9cbiAgICBkaXJlY3Rpb246IE5nYlNsaWRlRXZlbnREaXJlY3Rpb247XG59XG4vKipcbiAqIERlZmluZXMgdGhlIGNhcm91c2VsIHNsaWRlIHRyYW5zaXRpb24gZGlyZWN0aW9uLlxuICovXG5leHBvcnQgZGVjbGFyZSBlbnVtIE5nYlNsaWRlRXZlbnREaXJlY3Rpb24ge1xuICAgIExFRlQsXG4gICAgUklHSFRcbn1cbmV4cG9ydCBkZWNsYXJlIGNvbnN0IE5HQl9DQVJPVVNFTF9ESVJFQ1RJVkVTOiAodHlwZW9mIE5nYlNsaWRlIHwgdHlwZW9mIE5nYkNhcm91c2VsKVtdO1xuIl19